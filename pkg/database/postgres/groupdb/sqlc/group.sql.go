// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: group.sql

package groupdb

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const addGroupMember = `-- name: AddGroupMember :one
INSERT INTO group_members (
    group_id,
    member_id,
    role
) VALUES (
    $1, $2, $3
) RETURNING group_id, member_id, role, created_at
`

type AddGroupMemberParams struct {
	GroupID  int32  `json:"group_id"`
	MemberID int32  `json:"member_id"`
	Role     string `json:"role"`
}

func (q *Queries) AddGroupMember(ctx context.Context, arg AddGroupMemberParams) (GroupMember, error) {
	row := q.db.QueryRowContext(ctx, addGroupMember, arg.GroupID, arg.MemberID, arg.Role)
	var i GroupMember
	err := row.Scan(
		&i.GroupID,
		&i.MemberID,
		&i.Role,
		&i.CreatedAt,
	)
	return i, err
}

const addGroupTag = `-- name: AddGroupTag :one
INSERT INTO group_tags (
    group_id,
    tag_id
) VALUES (
    $1, $2
) RETURNING group_id, tag_id
`

type AddGroupTagParams struct {
	GroupID int32 `json:"group_id"`
	TagID   int32 `json:"tag_id"`
}

func (q *Queries) AddGroupTag(ctx context.Context, arg AddGroupTagParams) (GroupTag, error) {
	row := q.db.QueryRowContext(ctx, addGroupTag, arg.GroupID, arg.TagID)
	var i GroupTag
	err := row.Scan(&i.GroupID, &i.TagID)
	return i, err
}

const addMultipleTagsToGroup = `-- name: AddMultipleTagsToGroup :many
INSERT INTO group_tags (
    group_id,
    tag_id
) VALUES (
    $1, unnest($2::integer[])
) RETURNING group_id, tag_id
`

type AddMultipleTagsToGroupParams struct {
	GroupID int32   `json:"group_id"`
	Column2 []int32 `json:"column_2"`
}

func (q *Queries) AddMultipleTagsToGroup(ctx context.Context, arg AddMultipleTagsToGroupParams) ([]GroupTag, error) {
	rows, err := q.db.QueryContext(ctx, addMultipleTagsToGroup, arg.GroupID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GroupTag{}
	for rows.Next() {
		var i GroupTag
		if err := rows.Scan(&i.GroupID, &i.TagID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createGroup = `-- name: CreateGroup :one
INSERT INTO groups (
    group_name,
    group_creator_id,
    photo_url
) VALUES (
    $1, $2, $3
) RETURNING group_id, group_name, group_creator_id, photo_url, created_at
`

type CreateGroupParams struct {
	GroupName      string         `json:"group_name"`
	GroupCreatorID int32          `json:"group_creator_id"`
	PhotoUrl       sql.NullString `json:"photo_url"`
}

func (q *Queries) CreateGroup(ctx context.Context, arg CreateGroupParams) (Group, error) {
	row := q.db.QueryRowContext(ctx, createGroup, arg.GroupName, arg.GroupCreatorID, arg.PhotoUrl)
	var i Group
	err := row.Scan(
		&i.GroupID,
		&i.GroupName,
		&i.GroupCreatorID,
		&i.PhotoUrl,
		&i.CreatedAt,
	)
	return i, err
}

const createNewTag = `-- name: CreateNewTag :one
INSERT INTO tags (
    tag_name,
    icon_url
) VALUES (
    $1, $2
) RETURNING tag_id, tag_name, icon_url
`

type CreateNewTagParams struct {
	TagName string         `json:"tag_name"`
	IconUrl sql.NullString `json:"icon_url"`
}

func (q *Queries) CreateNewTag(ctx context.Context, arg CreateNewTagParams) (Tag, error) {
	row := q.db.QueryRowContext(ctx, createNewTag, arg.TagName, arg.IconUrl)
	var i Tag
	err := row.Scan(&i.TagID, &i.TagName, &i.IconUrl)
	return i, err
}

const deleteGroup = `-- name: DeleteGroup :exec
DELETE FROM groups
WHERE group_id = $1
`

func (q *Queries) DeleteGroup(ctx context.Context, groupID int32) error {
	_, err := q.db.ExecContext(ctx, deleteGroup, groupID)
	return err
}

const deleteMember = `-- name: DeleteMember :exec
DELETE FROM group_members 
WHERE member_id = $1 AND group_id = $2
`

type DeleteMemberParams struct {
	MemberID int32 `json:"member_id"`
	GroupID  int32 `json:"group_id"`
}

func (q *Queries) DeleteMember(ctx context.Context, arg DeleteMemberParams) error {
	_, err := q.db.ExecContext(ctx, deleteMember, arg.MemberID, arg.GroupID)
	return err
}

const editGroupName = `-- name: EditGroupName :exec
UPDATE groups SET group_name = $2
WHERE group_id = $1
`

type EditGroupNameParams struct {
	GroupID   int32  `json:"group_id"`
	GroupName string `json:"group_name"`
}

func (q *Queries) EditGroupName(ctx context.Context, arg EditGroupNameParams) error {
	_, err := q.db.ExecContext(ctx, editGroupName, arg.GroupID, arg.GroupName)
	return err
}

const editGroupPhoto = `-- name: EditGroupPhoto :exec
UPDATE groups SET photo_url = $2
WHERE group_id = $1
`

type EditGroupPhotoParams struct {
	GroupID  int32          `json:"group_id"`
	PhotoUrl sql.NullString `json:"photo_url"`
}

func (q *Queries) EditGroupPhoto(ctx context.Context, arg EditGroupPhotoParams) error {
	_, err := q.db.ExecContext(ctx, editGroupPhoto, arg.GroupID, arg.PhotoUrl)
	return err
}

const editMemberRole = `-- name: EditMemberRole :exec
UPDATE group_members SET role = $3
WHERE group_id = $1 AND member_id = $2
`

type EditMemberRoleParams struct {
	GroupID  int32  `json:"group_id"`
	MemberID int32  `json:"member_id"`
	Role     string `json:"role"`
}

func (q *Queries) EditMemberRole(ctx context.Context, arg EditMemberRoleParams) error {
	_, err := q.db.ExecContext(ctx, editMemberRole, arg.GroupID, arg.MemberID, arg.Role)
	return err
}

const getAvailableTags = `-- name: GetAvailableTags :many
SELECT tag_id, tag_name, icon_url FROM tags
ORDER BY tag_id
`

func (q *Queries) GetAvailableTags(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.TagID, &i.TagName, &i.IconUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupAndMemberByID = `-- name: GetGroupAndMemberByID :many
SELECT groups.group_id,
    groups.group_name,
    groups.photo_url,
    groups.created_at,
    group_members.member_id,
    group_members.role,
    group_members.created_at
FROM groups JOIN group_members ON groups.group_id = group_members.group_id
WHERE groups.group_id = $1
`

type GetGroupAndMemberByIDRow struct {
	GroupID     int32          `json:"group_id"`
	GroupName   string         `json:"group_name"`
	PhotoUrl    sql.NullString `json:"photo_url"`
	CreatedAt   time.Time      `json:"created_at"`
	MemberID    int32          `json:"member_id"`
	Role        string         `json:"role"`
	CreatedAt_2 time.Time      `json:"created_at_2"`
}

func (q *Queries) GetGroupAndMemberByID(ctx context.Context, groupID int32) ([]GetGroupAndMemberByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getGroupAndMemberByID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGroupAndMemberByIDRow{}
	for rows.Next() {
		var i GetGroupAndMemberByIDRow
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.MemberID,
			&i.Role,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupByID = `-- name: GetGroupByID :one
SELECT group_id, group_name, group_creator_id, photo_url, created_at FROM groups
WHERE group_id = $1
`

func (q *Queries) GetGroupByID(ctx context.Context, groupID int32) (Group, error) {
	row := q.db.QueryRowContext(ctx, getGroupByID, groupID)
	var i Group
	err := row.Scan(
		&i.GroupID,
		&i.GroupName,
		&i.GroupCreatorID,
		&i.PhotoUrl,
		&i.CreatedAt,
	)
	return i, err
}

const getGroupLatestId = `-- name: GetGroupLatestId :one
SELECT COALESCE(MAX(group_id), 0)::integer FROM groups
`

func (q *Queries) GetGroupLatestId(ctx context.Context) (int32, error) {
	row := q.db.QueryRowContext(ctx, getGroupLatestId)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getGroupsByTagName = `-- name: GetGroupsByTagName :many
SELECT groups.group_id, groups.group_name, groups.group_creator_id, groups.photo_url, groups.created_at FROM groups
JOIN group_tags ON groups.group_id = group_tags.group_id
JOIN tags ON group_tags.tag_id = tags.tag_id
WHERE tags.tag_name = $1
`

func (q *Queries) GetGroupsByTagName(ctx context.Context, tagName string) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, getGroupsByTagName, tagName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.GroupCreatorID,
			&i.PhotoUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMembersByGroupID = `-- name: GetMembersByGroupID :many
SELECT group_id, member_id, role, created_at FROM group_members
WHERE group_id = $1
`

func (q *Queries) GetMembersByGroupID(ctx context.Context, groupID int32) ([]GroupMember, error) {
	rows, err := q.db.QueryContext(ctx, getMembersByGroupID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GroupMember{}
	for rows.Next() {
		var i GroupMember
		if err := rows.Scan(
			&i.GroupID,
			&i.MemberID,
			&i.Role,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByGroupID = `-- name: GetTagsByGroupID :many
SELECT tags.tag_id, tags.tag_name, tags.icon_url FROM tags
JOIN group_tags ON tags.tag_id = group_tags.tag_id
WHERE group_tags.group_id = $1
`

func (q *Queries) GetTagsByGroupID(ctx context.Context, groupID int32) ([]Tag, error) {
	rows, err := q.db.QueryContext(ctx, getTagsByGroupID, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tag{}
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.TagID, &i.TagName, &i.IconUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroups = `-- name: ListGroups :many
SELECT group_id, group_name, group_creator_id, photo_url, created_at FROM groups
ORDER BY group_id
LIMIT $1
OFFSET $2
`

type ListGroupsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListGroups(ctx context.Context, arg ListGroupsParams) ([]Group, error) {
	rows, err := q.db.QueryContext(ctx, listGroups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Group{}
	for rows.Next() {
		var i Group
		if err := rows.Scan(
			&i.GroupID,
			&i.GroupName,
			&i.GroupCreatorID,
			&i.PhotoUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
