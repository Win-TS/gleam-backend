// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: friend.sql

package userdb

import (
	"context"
	"database/sql"
	"time"
)

const createFriend = `-- name: CreateFriend :one
INSERT INTO friends (
  user_id1,
  user_id2
) VALUES (
  $1, $2
) RETURNING id, user_id1, user_id2, status, created_at
`

type CreateFriendParams struct {
	UserId1 sql.NullInt32 `json:"user_id1"`
	UserId2 sql.NullInt32 `json:"user_id2"`
}

func (q *Queries) CreateFriend(ctx context.Context, arg CreateFriendParams) (Friend, error) {
	row := q.db.QueryRowContext(ctx, createFriend, arg.UserId1, arg.UserId2)
	var i Friend
	err := row.Scan(
		&i.ID,
		&i.UserId1,
		&i.UserId2,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const editFriendStatusAccepted = `-- name: EditFriendStatusAccepted :exec
UPDATE friends SET status = 'Accepted'
WHERE user_id1 = $1 AND user_id2 = $2
`

type EditFriendStatusAcceptedParams struct {
	UserId1 sql.NullInt32 `json:"user_id1"`
	UserId2 sql.NullInt32 `json:"user_id2"`
}

func (q *Queries) EditFriendStatusAccepted(ctx context.Context, arg EditFriendStatusAcceptedParams) error {
	_, err := q.db.ExecContext(ctx, editFriendStatusAccepted, arg.UserId1, arg.UserId2)
	return err
}

const editFriendStatusDeclined = `-- name: EditFriendStatusDeclined :exec
DELETE FROM friends
WHERE user_id1 = $1 AND user_id2 = $2
`

type EditFriendStatusDeclinedParams struct {
	UserId1 sql.NullInt32 `json:"user_id1"`
	UserId2 sql.NullInt32 `json:"user_id2"`
}

func (q *Queries) EditFriendStatusDeclined(ctx context.Context, arg EditFriendStatusDeclinedParams) error {
	_, err := q.db.ExecContext(ctx, editFriendStatusDeclined, arg.UserId1, arg.UserId2)
	return err
}

const getFriend = `-- name: GetFriend :one
SELECT id, user_id1, user_id2, status, created_at FROM friends
WHERE user_id1 = $1 AND user_id2= $2
LIMIT 1
`

type GetFriendParams struct {
	UserId1 sql.NullInt32 `json:"user_id1"`
	UserId2 sql.NullInt32 `json:"user_id2"`
}

func (q *Queries) GetFriend(ctx context.Context, arg GetFriendParams) (Friend, error) {
	row := q.db.QueryRowContext(ctx, getFriend, arg.UserId1, arg.UserId2)
	var i Friend
	err := row.Scan(
		&i.ID,
		&i.UserId1,
		&i.UserId2,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getFriendsCountByID = `-- name: GetFriendsCountByID :one
SELECT COUNT(*) FROM friends
WHERE (user_id1 = $1 OR user_id2 = $1) AND status = 'Accepted'
`

func (q *Queries) GetFriendsCountByID(ctx context.Context, userId1 sql.NullInt32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFriendsCountByID, userId1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFriendsPendingList = `-- name: GetFriendsPendingList :many
SELECT users.id, users.username, users.email, users.firstname, users.lastname, users.phone_no, users.private_account, users.nationality, users.birthday, users.gender, users.photourl, users.created_at FROM friends JOIN users ON friends.user_id1 = users.id
WHERE user_id2 = $1 AND status = 'Pending'
ORDER BY friends.created_at DESC
LIMIT $2 OFFSET $3
`

type GetFriendsPendingListParams struct {
	UserId2 sql.NullInt32 `json:"user_id2"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

func (q *Queries) GetFriendsPendingList(ctx context.Context, arg GetFriendsPendingListParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getFriendsPendingList, arg.UserId2, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Firstname,
			&i.Lastname,
			&i.PhoneNo,
			&i.PrivateAccount,
			&i.Nationality,
			&i.Birthday,
			&i.Gender,
			&i.Photourl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendsRequestedList = `-- name: GetFriendsRequestedList :many
SELECT users.id, users.username, users.email, users.firstname, users.lastname, users.phone_no, users.private_account, users.nationality, users.birthday, users.gender, users.photourl, users.created_at FROM friends JOIN users ON friends.user_id2 = users.id
WHERE user_id1 = $1 AND status = 'Pending'
ORDER BY friends.created_at DESC
LIMIT $2 OFFSET $3
`

type GetFriendsRequestedListParams struct {
	UserId1 sql.NullInt32 `json:"user_id1"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

func (q *Queries) GetFriendsRequestedList(ctx context.Context, arg GetFriendsRequestedListParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getFriendsRequestedList, arg.UserId1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Firstname,
			&i.Lastname,
			&i.PhoneNo,
			&i.PrivateAccount,
			&i.Nationality,
			&i.Birthday,
			&i.Gender,
			&i.Photourl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriendsByUserId = `-- name: ListFriendsByUserId :many
SELECT 
    CASE
        WHEN user_id1 = $1 THEN user_id2
        ELSE user_id1
    END AS friend_id,
    users.id, users.username, users.email, users.firstname, users.lastname, users.phone_no, users.private_account, users.nationality, users.birthday, users.gender, users.photourl, users.created_at
FROM 
    friends 
JOIN 
    users ON (CASE
                WHEN user_id1 = $1 THEN user_id2
                ELSE user_id1
            END) = users.id
WHERE 
    (user_id1 = $1 OR user_id2 = $1)
    AND status = 'Accepted'
ORDER BY 
    friend_id
LIMIT $2 OFFSET $3
`

type ListFriendsByUserIdParams struct {
	UserId1 sql.NullInt32 `json:"user_id1"`
	Limit   int32         `json:"limit"`
	Offset  int32         `json:"offset"`
}

type ListFriendsByUserIdRow struct {
	FriendID       interface{}    `json:"friend_id"`
	ID             int32          `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	Firstname      string         `json:"firstname"`
	Lastname       string         `json:"lastname"`
	PhoneNo        string         `json:"phone_no"`
	PrivateAccount bool           `json:"private_account"`
	Nationality    string         `json:"nationality"`
	Birthday       time.Time      `json:"birthday"`
	Gender         string         `json:"gender"`
	Photourl       sql.NullString `json:"photourl"`
	CreatedAt      time.Time      `json:"created_at"`
}

func (q *Queries) ListFriendsByUserId(ctx context.Context, arg ListFriendsByUserIdParams) ([]ListFriendsByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, listFriendsByUserId, arg.UserId1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFriendsByUserIdRow{}
	for rows.Next() {
		var i ListFriendsByUserIdRow
		if err := rows.Scan(
			&i.FriendID,
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Firstname,
			&i.Lastname,
			&i.PhoneNo,
			&i.PrivateAccount,
			&i.Nationality,
			&i.Birthday,
			&i.Gender,
			&i.Photourl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriendsByUserIdNoPaginate = `-- name: ListFriendsByUserIdNoPaginate :many
SELECT 
    CASE
        WHEN user_id1 = $1 THEN user_id2
        ELSE user_id1
    END AS friend_id,
    users.id, users.username, users.email, users.firstname, users.lastname, users.phone_no, users.private_account, users.nationality, users.birthday, users.gender, users.photourl, users.created_at
FROM 
    friends 
JOIN 
    users ON (CASE
                WHEN user_id1 = $1 THEN user_id2
                ELSE user_id1
            END) = users.id
WHERE 
    (user_id1 = $1 OR user_id2 = $1)
    AND status = 'Accepted'
ORDER BY 
    friend_id
`

type ListFriendsByUserIdNoPaginateRow struct {
	FriendID       interface{}    `json:"friend_id"`
	ID             int32          `json:"id"`
	Username       string         `json:"username"`
	Email          string         `json:"email"`
	Firstname      string         `json:"firstname"`
	Lastname       string         `json:"lastname"`
	PhoneNo        string         `json:"phone_no"`
	PrivateAccount bool           `json:"private_account"`
	Nationality    string         `json:"nationality"`
	Birthday       time.Time      `json:"birthday"`
	Gender         string         `json:"gender"`
	Photourl       sql.NullString `json:"photourl"`
	CreatedAt      time.Time      `json:"created_at"`
}

func (q *Queries) ListFriendsByUserIdNoPaginate(ctx context.Context, userId1 sql.NullInt32) ([]ListFriendsByUserIdNoPaginateRow, error) {
	rows, err := q.db.QueryContext(ctx, listFriendsByUserIdNoPaginate, userId1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFriendsByUserIdNoPaginateRow{}
	for rows.Next() {
		var i ListFriendsByUserIdNoPaginateRow
		if err := rows.Scan(
			&i.FriendID,
			&i.ID,
			&i.Username,
			&i.Email,
			&i.Firstname,
			&i.Lastname,
			&i.PhoneNo,
			&i.PrivateAccount,
			&i.Nationality,
			&i.Birthday,
			&i.Gender,
			&i.Photourl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
